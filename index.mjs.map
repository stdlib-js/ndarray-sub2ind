{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport isArray from '@stdlib/assert-is-array';\nimport isOrder from '@stdlib/ndarray-base-assert-is-order';\nimport isIndexMode from '@stdlib/ndarray-base-assert-is-index-mode';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {(StringArray|string)} [options.mode] - specifies how to handle subscripts which exceed array dimensions\n* @param {string} [options.order] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'mode': 'throw',\n*     'order': 'column-major'\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tvar i;\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( '0N22h', options ) );\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\topts.mode = options.mode;\n\t\tif ( !isArray( opts.mode ) ) {\n\t\t\topts.mode = [ opts.mode ];\n\t\t} else if ( opts.mode.length === 0 ) {\n\t\t\treturn new TypeError( format( '0N265', 'mode' ) );\n\t\t}\n\t\tfor ( i = 0; i < opts.mode.length; i++ ) {\n\t\t\tif ( !isIndexMode( opts.mode[ i ] ) ) {\n\t\t\t\treturn new TypeError( format( '0N260', 'mode', opts.mode[ i ] ) );\n\t\t\t}\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'order' ) ) {\n\t\topts.order = options.order;\n\t\tif ( !isOrder( opts.order ) ) {\n\t\t\treturn new TypeError( format( '0N261', 'order', opts.order ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { primitives as isNonNegativeIntegerArray } from '@stdlib/assert-is-nonnegative-integer-array';\nimport { isPrimitive as isInteger } from '@stdlib/assert-is-integer';\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport getIndex from '@stdlib/ndarray-base-sub2ind';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport defaults from './defaults.json';\nimport validate from './validate.js';\n\n\n// MAIN //\n\n/**\n* Converts subscripts to a linear index.\n*\n* ## Notes\n*\n* -   The function accepts the following \"modes\":\n*\n*     -   `throw`: throws an error when a subscript exceeds array dimensions.\n*     -   `wrap`: wrap around subscripts exceeding array dimensions using modulo arithmetic.\n*     -   `clamp`: set subscripts exceeding array dimensions to either `0` (minimum index) or the maximum index along a particular dimension.\n*\n* -   If provided fewer modes than dimensions, the function recycles modes using modulo arithmetic.\n*\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {...integer} i - subscripts\n* @param {Options} [options] - function options\n* @param {(StringArray|string)} [options.mode=[\"throw\"]] - specifies how to handle subscripts which exceed array dimensions\n* @param {string} [options.order=\"row-major\"] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)\n* @throws {TypeError} first argument must be an array-like object containing nonnegative integers\n* @throws {TypeError} subscripts must be integer valued\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {RangeError} must provide subscripts which do not exceed array dimensions\n* @throws {RangeError} number of subscripts much match the number of dimensions\n* @returns {NonNegativeInteger} linear index\n*\n* @example\n* var i = sub2ind( [ 3, 3, 3 ], 1, 2, 2 );\n* // returns 17\n*/\nfunction sub2ind() {\n\tvar options;\n\tvar shape;\n\tvar ndims;\n\tvar args;\n\tvar opts;\n\tvar err;\n\tvar len;\n\tvar i;\n\tvar j;\n\n\tshape = arguments[ 0 ];\n\tif ( !isNonNegativeIntegerArray( shape ) ) {\n\t\tthrow new TypeError( format( '0N262', shape ) );\n\t}\n\tlen = arguments.length;\n\tndims = shape.length;\n\n\topts = {};\n\topts.mode = defaults.mode.slice();\n\topts.order = defaults.order;\n\n\tif ( len > ndims+1 ) {\n\t\tj = len - 1;\n\t\toptions = arguments[ j ];\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t} else {\n\t\tj = len;\n\t}\n\ti = 1;\n\tif ( j-i !== ndims ) {\n\t\tthrow new RangeError( format( 'invalid argument. Number of provided subscripts must match the number of dimensions. ndims: `%u`. Number of subscripts: `%u`.', ndims, j-i ) );\n\t}\n\targs = new Array( ndims+4 );\n\targs[ 0 ] = shape;\n\targs[ 1 ] = shape2strides( shape, opts.order );\n\targs[ 2 ] = 0; // strides are positive, so offset is always zero\n\tfor ( ; i < j; i++ ) {\n\t\tif ( !isInteger( arguments[ i ] ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Subscripts must be integer valued. Argument: `%u`. Value: `%s`.', i, arguments[ i ] ) );\n\t\t}\n\t\targs[ i+2 ] = arguments[ i ];\n\t}\n\targs[ i+2 ] = opts.mode; // i+2 == args.length-1\n\treturn getIndex.apply( null, args );\n}\n\n\n// EXPORTS //\n\nexport default sub2ind;\n"],"names":["validate","opts","options","i","isObject","TypeError","format","hasOwnProp","mode","isArray","length","isIndexMode","order","isOrder","sub2ind","shape","ndims","args","err","len","j","isNonNegativeIntegerArray","arguments","defaults","slice","RangeError","Array","shape2strides","isInteger","getIndex","apply"],"mappings":";;s+BAqDA,SAASA,EAAUC,EAAMC,GACxB,IAAIC,EACJ,IAAMC,EAAUF,GACf,OAAO,IAAIG,UAAWC,EAAQ,QAASJ,IAExC,GAAKK,EAAYL,EAAS,QAAW,CAEpC,GADAD,EAAKO,KAAON,EAAQM,KACdC,EAASR,EAAKO,OAEb,GAA0B,IAArBP,EAAKO,KAAKE,OACrB,OAAO,IAAIL,UAAWC,EAAQ,QAAS,cAFvCL,EAAKO,KAAO,CAAEP,EAAKO,MAIpB,IAAML,EAAI,EAAGA,EAAIF,EAAKO,KAAKE,OAAQP,IAClC,IAAMQ,EAAaV,EAAKO,KAAML,IAC7B,OAAO,IAAIE,UAAWC,EAAQ,QAAS,OAAQL,EAAKO,KAAML,IAG5D,CACD,OAAKI,EAAYL,EAAS,WACzBD,EAAKW,MAAQV,EAAQU,OACfC,EAASZ,EAAKW,QACZ,IAAIP,UAAWC,EAAQ,QAAS,QAASL,EAAKW,QAGhD,IACR,CCdA,SAASE,IACR,IACIC,EACAC,EACAC,EACAhB,EACAiB,EACAC,EACAhB,EACAiB,EAGJ,IAAMC,EADNN,EAAQO,UAAW,IAElB,MAAM,IAAIjB,UAAWC,EAAQ,QAASS,IASvC,GAPAI,EAAMG,UAAUZ,OAChBM,EAAQD,EAAML,QAEdT,EAAO,CAAA,GACFO,KAAOe,EAASf,KAAKgB,QAC1BvB,EAAKW,MAAQW,EAASX,MAEjBO,EAAMH,EAAM,GAIhB,GADAE,EAAMlB,EAAUC,EADNqB,UADVF,EAAID,EAAM,IAIT,MAAMD,OAGPE,EAAID,EAGL,GAAKC,GADLjB,EAAI,KACSa,EACZ,MAAM,IAAIS,WAAYnB,EAAQ,gIAAiIU,EAAOI,EAAEjB,IAMzK,KAJAc,EAAO,IAAIS,MAAOV,EAAM,IAClB,GAAMD,EACZE,EAAM,GAAMU,EAAeZ,EAAOd,EAAKW,OACvCK,EAAM,GAAM,EACJd,EAAIiB,EAAGjB,IAAM,CACpB,IAAMyB,EAAWN,UAAWnB,IAC3B,MAAM,IAAIE,UAAWC,EAAQ,oFAAqFH,EAAGmB,UAAWnB,KAEjIc,EAAMd,EAAE,GAAMmB,UAAWnB,EACzB,CAED,OADAc,EAAMd,EAAE,GAAMF,EAAKO,KACZqB,EAASC,MAAO,KAAMb,EAC9B"}